Programming as a Way of Life
Homework 6 Problems

Group 05 
Group Member 1 Katrina Sayre
Group Member 2 Alexei McConville

###################################################################################
Problem 3: Nested Data Structures

Sets, tuples, and dictionaries are all types of data structures.  They can be used individually or can be
"nested" inside of eachother.  For example, you can have a dictionary containing a list.

"A tuple is a sequence of values. The values can be any type, and they are indexed by
integers, so in that respect tuples are a lot like lists. The important difference is that tuples
are immutable.
A dictionary is like a list, but more general. In a list, the indices have to be integers; in a
dictionary they can be (almost) any type.
You can think of a dictionary as a mapping between a set of indices (which are called keys)
and a set of values. Each key maps to a value. The association of a key and a value is called
a key-value pair or sometimes an item."*
A set can store certain values without any particular order and no repeated values.

Data structure indicators:
set = set[1,2,3]
tuple = (  )
dictionary = {  }

Dictionary example: 
d = { "Mom" : "360-555-1111", "Dad" : "360-111-5555" }

d ["Mom"]
#output
"360-555-1111"

#can reassign
d["Mom"] = "360-999-3333"

d ["Mom"]
#output
"360-999-3333"

~Practice making individual data structures:
  Make a tuple.
  Make a set.
  Make a dictionary.
  
Now, practice making nested data structures:
  Make a set containing a dictionary.
  Make a set containing a tuple.
  Make a set containing a dictionary that contains a set.
  
Note: When using an interpreter, you can determine what type something is by calling on the keyword 'type'.  The return
value is the type of object. 

###################################################################################
Problem 4: 'for' and 'if' statements

"The syntax of a 'for' statement is similar to a function deﬁnition. It has a header that ends
with a colon and an indented body. The body can contain any number of statements.
A for statement is sometimes called a loop because the ﬂow of execution runs through the
body and then loops back to the top."*

Example of a 'for' statement:

n = 25
x = 0
for i in range(n):
  x = x + i
  print x
  
~Practice making a 'for' loop:
Assign a variable to some number. Use a 'for' statement to indicate the range of that variable.  Have another variable, 
which you identify before the 'for' statement.  Increase your second variable by the range of your first (add x+1, 
x+2,... x+n).

###################################################################################
Problem 5: Definitions

"A function deﬁnition speciﬁes the name of a new function and the
sequence of statements that execute when the function is called.

Here is an example:
def print_lyrics():
  print "I'm a lumberjack, and I'm okay."
  print "I sleep all night and I work all day."
  
def is a keyword that indicates that this is a function deﬁnition. The name of the function
is print_lyrics. The rules for function names are the same as for variable names: letters,
numbers and some punctuation marks are legal, but the ﬁrst character can’t be a number.
You can’t use a keyword as the name of a function, and you should avoid having a variable
and a function with the same name.
The empty parentheses after the name indicate that this function doesn’t take any arguments.
The ﬁrst line of the function deﬁnition is called the header; the rest is called the body.
The header has to end with a colon and the body has to be indented. By convention, the
indentation is always four spaces (see Section 3.14). The body can contain any number of
statements."*

~Practice:
Define a function that, when called, prints your full name, first, middle, and last - each on separate lines. 

###################################################################################
Problem 6: 'assert'

An 'assert' call means everything that follows is Boolean (True or False). 'Assert' helps to fix bugs in your program by 
confirming that all that should be true is and, if not, gives you an 'assertion error'.
After you define a function, you can use the 'assert' to confirm that the function is working correctly.  

~Practice:
Define a function (call it 'square') that finds the square of a number, x. 
Define a test function (call it 'test_square') that confirms (via 'assert') that your previous 'square' 
function works properly (give x any value and call your 'square' function - use a whole number).

###################################################################################
Problem 7: 'return' and 'pass' 

The 'pass' keyword does nothing - it is handy when you have a function that is not implemented yet, but the body of
the function cannot be empty - so, until you implement the function 'pass' will stop the interpreter from barking at you.
example:

def function():
  pass
  
  
The 'return' keyword works with function defintions; it exits the function and returns a value. 
example:

def cube(x):
  return x * x * x
  
a = cube(7)
b = cube(26)

# the function will calculate the cube of a number, the 'return' key will exit the function and return 
# a value, that value is then assigned to the a, b variables.  

~Practice: 
Define a function and pass it.  Define another function and return a value. Feel free to use previously defined 
functions. 



**** All quoted information is from our textbook, Think Python.


###################################################################################
Example of 'assert', 'return', sets, dictionaries, and function defintions:

FILE 1:
def row_to_edge(row):
    """
    Given an election result row or poll data row, returns the Democratic edge
    in that state.
    """
    return float(row["Dem"]) - float(row["Rep"])  

FILE 2:
def test_row_to_edge( ):
    row1 = { "Dem": 41.3, "Rep": 55.3 }
    assert row_to_edge(row1) == -14

    row2 = { "Dem": 38.4, "Rep": 60.7 }
    assert row_to_edge(row2) == -22.3

    row3 = { "Dem": 36.9, "Rep": 60.5}
    assert row_to_edge(row3) == -23.6
    
The defined function, row_to_edge, in File 1 is written such that the 'assert' statements are true. File 2 defines 
and calls a function that is identical (in effect) to the function defined and called in File 1.  File 2 then uses 
'assert' to test. 

###################################################################################
Example: 

Create a text file that has the following information, in seperate columns and rows: 

Letter   X       Y
w        77      5
z        88      14


Import that information into your program.  

Define a function, call it "first", that subtracts y from x for both letters, w and z.  
Confirm that it is correct using a test function and 'assert'.

Define another function that creates a dictionary for each letter which contains the name of the letter 
and the value that is returned by the "first" function. (Your goal output is {'w': '72'} for the first row.)
Confirm that it is working correctly using a test function and 'assert'.

Example answer: 

import file

def first(row):
  return float(row["X"]) - float(row["Y"])
  
def test_first( ):
  row1 = { "X": 77, "Y": 5 }
  assert first(row1) == 72
  
def second(rows):  
    first_diction = { }
    for row in rows:
        result = first(row)
        letter = (row('Letter')
        first_diction[letter] = result
    return first_diction

def test_first_diction( ):
    rows1 = [ { 'Letter': 'w', 'X': '77', 'Y': '5' } ] 
    assert first_diction(rows1) == { 'w': '72' }




